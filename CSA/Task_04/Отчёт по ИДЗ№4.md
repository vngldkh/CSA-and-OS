# Отчёт по ИДЗ№4
## Гладких Иван БПИ219
### Вариант 35
**Задача о читателях и писателях - 2 («грязное чтение»).**
Базу данных разделяют два типа потоков – читатели и писатели. 
Читатели выполняют транзакции, которые просматривают записи базы данных. Транзакции писателей и просматривают, и изменяют записи. Предполагается, что в начале БД находится в непротиворечивом состоянии (например, если каждый элемент — число, то они все отсортированы). Транзакции выполняются в режиме «грязного чтения». То есть процесс-писатель не может получить доступ к БД только в том случае, если ее уже занял другой процесс-писатель, а процессы читатели ему не мешают обратиться к БД. 
*Создать многопоточное приложение с потоками-писателями и потоками-читателями. Реализовать решение, используя семафоры, и не используя блокировки чтения-записи.*

***Задание решено на 8 баллов***

Исходный код - [./main.cpp](./main.cpp)

#### Правила эксплуатации
Ввод и вывод программы работает в 4 форматах:
- С помощью консоли
- С помощью отдельных файлов
- С помощью аргументов командной строки
- Рандомно

Чтобы запустить тот или иной режим работы, первым аргументом (после названия исполняемого файла) необходимо передать соответствующий ключ.

Необходимые аргументы командной строки для каждого режима работы:
Режим работы | argv[0] | argv[1] | argv[2] | argv[3]| argv[4]
-------------|---------|---------|---------|--------|--------
Консоль|Имя исполняемого файла (./a.out)|0|-|-|-
Файлы|Имя исполняемого файла (./a.out)|1|Имя входного файла (input.txt)|-|-
Аргументы командной строки|Имя исполняемого файла (./a.out)|2|Размер БД|Число потоков-писателей| Число потоков-читателей
Рандомно|Имя исполняемого файла (./a.out)|3|-|-|-

Программа работает бесконечно.
Чтобы остановить её, необходимо ввести символ *q* и нажать *enter*. 

Программа предусматривает ввод некорректных данных.
- Если вместо числа введена строка, вводимое число примет значение 0.
- Если размер контейнера = 0, программа сразу заканчивает работу.
- Если кол-во потоков-читателей и кол-во потоков-писателей = 0, программа сразу завершает работу.

### Модель параллельных вычислений
Программа представляет собой EREW (Exclusive Read Exclusive Write) - PRAM модель запрещает параллельный доступ к ячейке памяти и по чтению, и по записи.
Есть единый контейнер (база данных) с произвольным доступом. Каждый поток может обратиться к одной из ячеек контейнере и прочитать из нее информацию и\или записать новые данные. Причём поток-читатель блокирует ячейку для чтения читателями, а поток-писатель блокирует ячейку для чтения и записи другими писателями.
[Источник](https://vestnik.susu.ru/cmi/article/viewFile/8796/7201)

### Сценарий в терминах предметной области
Существует некая база данных, а также два непротиворечащих типа сущностей, привязанных к этой БД: читатель и писатель.
В любой момент времени сущность одного из двух типов может выбрать любую ячейку БД, не занятую другой сущностью соответствующего типа и проделать с ней определённые действия. То есть читатель может взять любую ячейку, не занятую другим читателем, и прочитать хранящуюся в ней информацию. Писатель может в то же время выбрать любую ячейку, не занятую другим писателем (но возможно занятую читателем), прочитать, хранящуюся в ней информацию, и изменить её (по условию транзакции писателей и просматривают, и изменяют).

### Обобщённый алгоритм
База данных представляется контейнером, читатели и писатели потоками с соответствующими функциями.

Каждый поток циклично выполняет следующую последовательность действий:
- Выбирает ячейку
- Блокирует ее для остальных потоков того же типа
- Выполняет поставленную задачу
- Освобождает ячейку

Последовательность для потоков-читателей и потоков-писателей одинакова, различается только задача, поставленная перед потоком.

Когда поток выбирает ячейку БД, она блокируется для остальных потоков того же типа, чтобы избежать ситуаций неуправляемого изменения одних и тех же общих данных несколькими потоками и их несогласованного поведения.

Над базой данных максимум одновременно может работать такое кол-во потоков одного типа, каков размер БД, поэтому, когда над БД в один момент работает максимальное кол-во потоков, остальные потоки того же типа блокируются.

### Описание программы
Создаётся единый контейнер - std::vector<int> пользовательской\случайной длины.
Изначально он заполнен последовательностью натуральных чисел от 1 до размера вектора.
Есть N читателей и M писателей. Числа N и M вводятся пользователем или определяются случайно.
Так как читатели не мешают писателям (и наоборот), создаются отдельные семафоры - один для читателей, один для писателей, то же самое с мутексами. 
Семафор ограничивает кол-во работающих над БД потоков: оно не превышет размер контейнера.
Мутекс блокирует ячейку для потоков того же типа, чтобы избежать ситуаций неуправляемого изменения одних и тех же общих данных несколькими потоками и их несогласованного поведения.
После завершения обработки ячейки поток засыпает на некоторое время (случайное).
Таким образом потоки циклично ходят по контейнеру, выполняя заданные функции.
При вводе пользователем *q* закрываются входные\выходные потоки (данные сохраняются), main завершает работу, работающие потоки умирают.

### Тестовые данные
Можно найти тут: [./test_input/](./test_input/)
№ Теста| Размер контейнера | Кол-во писателей | Кол-во читателей
-------|--------|--------|--------
1|13 |13 |13
2|5 |18 |36
3|25 |4 |4
4|0|0|0
5|fdg |34 |5
6|13 |0 |7
7|128 |0 |0
Результаты тестовых прогонов: [./test_output/](./test_output/) 
*(Для некоторых исходных данных тесмты отсутствуют, так как программа завершала свою работу раньше какого-либо вывода в связи с введёёными данными)*
Результаты случайных тестов: [./random_test/](./random_test/) 
*(В конце файлов случайных тестов представлены сгенерированные данные)*

